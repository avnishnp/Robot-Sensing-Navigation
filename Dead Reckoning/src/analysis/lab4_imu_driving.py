# -*- coding: utf-8 -*-
"""Lab4 IMU_Driving.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1s_bmmKmwgT3--boDeF3rP4tRV-kHKcIC
"""

!pip install bagpy

import bagpy
from bagpy import bagreader
import pandas as pd
import seaborn as sea
import matplotlib.pyplot as plt
import numpy as np

b = bagreader('driving.bag')

# get the list of topics
print(b.topic_table)

data = b.message_by_topic('/imu')
print("File saved: {}".format(data))

# pd.set_option('display.float_format', '{:.6f}'.format)

df_imu = pd.read_csv(data)
df_imu

def quaternion_to_euler_angle(w, x, y, z):
    ysqr = y * y

    t0 = +2.0 * (w * x + y * z)
    t1 = +1.0 - 2.0 * (x * x + ysqr)
    X = np.degrees(np.arctan2(t0, t1))

    t2 = +2.0 * (w * y - z * x)
    t2 = np.where(t2>+1.0,+1.0,t2)
    #t2 = +1.0 if t2 > +1.0 else t2

    t2 = np.where(t2<-1.0, -1.0, t2)
    #t2 = -1.0 if t2 < -1.0 else t2
    Y = np.degrees(np.arcsin(t2))

    t3 = +2.0 * (w * z + x * y)
    t4 = +1.0 - 2.0 * (ysqr + z * z)
    Z = np.degrees(np.arctan2(t3, t4))

    return X, Y, Z

quat_df=df_imu[['IMU.orientation.x','IMU.orientation.y','IMU.orientation.z','IMU.orientation.w']]

quat_df

import pandas as pd
from scipy.spatial.transform import Rotation

rot = Rotation.from_quat(quat_df)
rot_euler = rot.as_euler('xyz', degrees=True)
euler_df = pd.DataFrame(data=rot_euler, columns=['x', 'y', 'z'])

df_imu.plot(x='Time',y='MagField.magnetic_field.x')
plt.xlabel("Time (s)")
plt.ylabel("Magnetic Field (Gauss)")
plt.title("Time vs Magnetic Field (X) ")

df_imu.plot(x='MagField.magnetic_field.x',y='MagField.magnetic_field.y')
plt.xlabel("Magnetic Field X(Gauss)")
plt.ylabel("Magnetic Field Y(Gauss)")
plt.title("In Circles ")

from mpl_toolkits.mplot3d import Axes3D
from scipy import linalg

def fitEllipsoid(magX, magY, magZ):
    a1 = magX ** 2
    a2 = magY ** 2
    a3 = magZ ** 2
    a4 = 2 * np.multiply(magY, magZ)
    a5 = 2 * np.multiply(magX, magZ)
    a6 = 2 * np.multiply(magX, magY)
    a7 = 2 * magX
    a8 = 2 * magY
    a9 = 2 * magZ
    a10 = np.ones(len(magX)).T
    D = np.array([a1, a2, a3, a4, a5, a6, a7, a8, a9, a10])

    # Eqn 7, k = 4
    C1 = np.array([[-1, 1, 1, 0, 0, 0],
                   [1, -1, 1, 0, 0, 0],
                   [1, 1, -1, 0, 0, 0],
                   [0, 0, 0, -4, 0, 0],
                   [0, 0, 0, 0, -4, 0],
                   [0, 0, 0, 0, 0, -4]])

    # Eqn 11
    S = np.matmul(D, D.T)
    S11 = S[:6, :6]
    S12 = S[:6, 6:]
    S21 = S[6:, :6]
    S22 = S[6:, 6:]

    # Eqn 15, find eigenvalue and vector
    # Since S is symmetric, S12.T = S21
    tmp = np.matmul(np.linalg.inv(C1), S11 - np.matmul(S12, np.matmul(np.linalg.inv(S22), S21)))
    eigenValue, eigenVector = np.linalg.eig(tmp)
    u1 = eigenVector[:, np.argmax(eigenValue)]

    # Eqn 13 solution
    u2 = np.matmul(-np.matmul(np.linalg.inv(S22), S21), u1)

    # Total solution
    u = np.concatenate([u1, u2]).T

    Q = np.array([[u[0], u[5], u[4]],
                  [u[5], u[1], u[3]],
                  [u[4], u[3], u[2]]])

    n = np.array([[u[6]],
                  [u[7]],
                  [u[8]]])

    d = u[9]

    return Q, n, d

magX= (df_imu['MagField.magnetic_field.x'])  # Gauss
magY= (df_imu['MagField.magnetic_field.y'] )
magZ= (df_imu['MagField.magnetic_field.z'])

gx= df_imu['IMU.angular_velocity.x']  # rad/s
gy= df_imu['IMU.angular_velocity.y'] 
gz= df_imu['IMU.angular_velocity.z']

acX= (df_imu['IMU.linear_acceleration.x'])  # Gauss
acY= (df_imu['IMU.linear_acceleration.y'] )
acZ= (df_imu['IMU.linear_acceleration.z'])

#Hard Iron distortion

offset_x = (max(magX) + min(magX)) / 2
offset_y = (max(magY) + min(magY)) / 2
offset_z = (max(magZ) + min(magZ)) / 2

corrected_x = magX - offset_x
corrected_y = magY - offset_y
corrected_z = magZ - offset_z
# print(corrected_x, corrected_y, corrected_z)

fig, ax2 = plt.subplots()
ax2.scatter(magX,magY)
ax2.scatter(corrected_x,corrected_y)
# ax2.scatter(corrected_y,corrected_z)
# ax2.scatter(corrected_x,corrected_z)

# plt.scatter(y_int,df_imu['Time'])

# import math
# # yaw from gyroscope data
# x1=[]
# for l in df_imu['IMU.angular_velocity.y']:
#   for o in df_imu['IMU.angular_velocity.z']:
#     x1.append(math.atan2(l,o))

# # x1=math.atan2(df_imu['IMU.angular_velocity.y'],df_imu['IMU.angular_velocity.z'])

df_copy=df_imu.copy()

df_copy

import math
series = df_imu["IMU.orientation.x"]
df_copy['CosX']=series.apply(math.cos)
df_copy['SinX']=series.apply(math.sin)
series1 = df_imu["IMU.orientation.y"]
df_copy['CosY']=series1.apply(math.cos)
df_copy['SinY']=series1.apply(math.sin)
Yh=corrected_y * df_copy['CosX'] - corrected_z*df_copy['SinX']
Xh=corrected_x*df_copy['CosY'] +corrected_y*df_copy['SinX']*df_copy['SinY'] + corrected_z*df_copy['CosX']*df_copy['SinY']
df_copy['Yh']=Yh
df_copy['Xh']=Xh
# df_copy['MagYaw']=df_copy['MagYaw'].apply(math.atan2(df_copy['Yh'],df_copy['Xh']))
# df_copy['MagYaw']=df_copy['MagYaw'].apply(math.atan2(yaw))
df_copy['MagYaw'] = df_copy.apply(lambda row: math.atan2(row.Yh ,
                                  (row.Xh )), axis = 1)
df_copy['MagYaw_shift'] = np.unwrap(df_copy['MagYaw'])

df_copy['MagYaw_shift']

fig = plt.figure()
ax1 = fig.add_subplot(111)
ax1.scatter(df_copy['Yh'],df_copy['Xh'],label='corrected')
ax1.scatter(magX,magY,label='original')
plt.legend()

scatter=plt.plot(corrected_x,corrected_y, df_copy['Yh'],df_copy['Xh'])
plt.legend(scatter,('Corrected','Original'))

# import math
# Yh=[]
# Xh=[]
# for i in df_imu['IMU.orientation.x']:
#   for j in df_imu['IMU.orientation.y']:
#     Xh.append(magX * math.cos(j) + magY*math.sin(i)*math.sin(j) + magZ*math.cos(i)*math.sin(j))
#     Yh.append(magY *math.cos(i) - magZ*math.sin(i))


# # Yh = (magY * math.cos(df_imu['IMU.orientation.x'])) - (magZ * math.sin(df_imu['IMU.orientation.x']))
# # Xh = (magX * math.cos(df_imu['IMU.orientation.y']))+(magY * math.sin(df_imu['IMU.orientation.x'])*math.sin(df_imu['IMU.orientation.y'])) + (magZ * math.cos(df_imu['IMU.orientation.x']) * math.sin(df_imu['IMU.orientation.y']))

# # yaw

# Xh=[]
# for j in df_imu['IMU.orientation.y']:
#   Xh.append(magX * math.cos(j) + magY*math.sin(i)*math.sin(j) + magZ*math.cos(i)*math.sin(j))

# yaw =  math.atan2(Yh, Xh)

#Soft Iron Distortion
avg_delta_x = (max(magX) - min(magX)) / 2
avg_delta_y = (max(magY) - min(magY)) / 2
avg_delta_z = (max(magZ) - min(magZ)) / 2

avg_delta = (avg_delta_x + avg_delta_y + avg_delta_z) / 3

scale_x = avg_delta / avg_delta_x
scale_y = avg_delta / avg_delta_y
scale_z = avg_delta / avg_delta_z

corrected_xs = magX * scale_x
corrected_ys = magY * scale_x
corrected_zs = magZ * scale_x

scatter=plt.plot(corrected_xs,corrected_ys, df_copy['Yh'],df_copy['Xh'])
plt.legend(scatter,('Corrected','Original'))

from scipy import integrate
y_intx = integrate.cumtrapz(df_imu['IMU.angular_velocity.x'], initial=0)
y_inty = integrate.cumtrapz(df_imu['IMU.angular_velocity.y'], initial=0)
y_intz = integrate.cumtrapz(df_imu['IMU.angular_velocity.z'], initial=0)

fig = plt.figure()
ax2 = fig.add_subplot(111)
ax2.scatter(df_imu['Time'],df_copy['MagYaw_shift'],label='Magno')
ax2.scatter(df_imu['Time'],y_intz,label='Gyro')
plt.legend()

!pip install numpy-quaternion

alpha =0.6
N = len(df_imu['Time'])
dt = np.diff(df_imu['Time'])
angle_gyro=0.0
angle_mag=0.0
for i in range(1,N):
    # Update complimentary filter
    angle_gyro=(1 - alpha) *y_intz[i] + (1- alpha)*((y_intz)-(y_intz[i-1]))
    angle_mag=(1 - alpha) * df_copy['MagYaw'][i] + alpha * df_copy['MagYaw'][i-1]
    angle_t = angle_gyro+angle_mag



fig = plt.figure()
ax3 = fig.add_subplot(111)
ax3.plot(df_copy['MagYaw'],df_imu['Time'],label='Magno')
ax3.scatter(y_intz,df_imu['Time'],label='Gyro')
ax3.scatter(angle_t,df_imu['Time'],label='Filter')
plt.legend()

normacc=pd.DataFrame()

normacc['LinX']=df_imu['IMU.linear_acceleration.x']
normacc['LinY']=df_imu['IMU.linear_acceleration.y']
normacc['LinZ']=df_imu['IMU.linear_acceleration.z']

normacc

normacc['VelX']= integrate.cumtrapz(normacc['LinX'], initial=0)
normacc['VelY'] = integrate.cumtrapz(normacc['LinY'], initial=0)
normacc['VelZ'] = integrate.cumtrapz(normacc['LinZ'], initial=0)

normacc['MagLX']=np.linalg.norm(normacc['LinX'])
normacc['MagLY']=np.linalg.norm(normacc['LinY'])
normacc['MagLZ']=np.linalg.norm(normacc['LinZ'])

normacc.drop(['MagLX','MagLY','MagLZ'],axis=1,inplace=True)

normacc["Total_acc"]=np.sqrt(np.square(normacc).sum(axis=1))

normacc

gps_data = b.message_by_topic('/gps')
print("File saved: {}".format(gps_data))

df_gps = pd.read_csv(gps_data)
df_gps

from geopy.distance import distance
from geopy import Point
lat= df_gps['Latitude'] * (math.pi/180)
lon = df_gps['Longitude'] * (math.pi/180)
(lat,lon)=df_gps['Latitude'] ,df_gps['Longitude']
latdiff=lat.diff()
londiff=lon.diff()

df_gps['point'] = df_gps.apply(lambda row: Point(latitude=row['Latitude'], longitude=row['Longitude']), axis=1)
df_gps['point_next'] = df_gps['point'].shift(1)
df_gps.loc[df_gps['point_next'].isna(), 'point_next'] = None
df_gps['distance_km'] = df_gps.apply(lambda row: distance(row['point'], row['point_next']).m if row['point_next'] is not None else float('nan'), axis=1)
df_gps = df_gps.drop('point_next', axis=1)

# create a new column for velocity
diff=df_gps['Time'].diff()
dist=df_gps['distance_km'] 
g=dist/diff
df_gps['velocity'] = g

df_gps['velocity']

df_gps['velocity'].shape

fig = plt.figure()
ax4 = fig.add_subplot(111)
ax4.scatter(df_gps['velocity'],df_gps['Time'],label='Gps velocity')
ax4.scatter(normacc['VelX'],df_imu['Time'],label='Acc velocity')
plt.legend()

for i in range(1,N):
    # Update complimentary filter
    angle_acc=(1 - alpha) * normacc['LinX'][i] + alpha * normacc['LinX'][i-1]

normacc['Angle_acc'] = angle_acc

normacc['Velocity_X2'] = integrate.cumtrapz(normacc['Angle_acc'], initial=0)

fig = plt.figure()
ax5 = fig.add_subplot(111)
ax5.scatter(df_gps['velocity'],df_gps['Time'],label='Gps velocity')
ax5.scatter(normacc['Velocity_X2'],df_imu['Time'],label='Acc New velocity')
ax5.scatter(normacc['VelX'],df_imu['Time'],label='Acc Old velocity')
plt.legend()

"""**Dead Reckoning (Displacement)**"""

disp_df=pd.DataFrame()

disp_df['Disp'] = integrate.cumtrapz(normacc['Velocity_X2'], initial=0)

fig = plt.figure()
ax6 = fig.add_subplot(111)
ax6.scatter(disp_df['Disp'],df_imu['Time'],label='Acc Displacement')
ax6.scatter(df_gps['distance_km'],df_gps['Time'],label='GPS displacement')
plt.legend()

from scipy.spatial.transform import Rotation as R
r = R.from_rotvec([normacc['LinX'], normacc['LinY'], normacc['LinZ']])

